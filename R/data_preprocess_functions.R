

##################################################################################
## function to process polII expression matrix and add top 10% info
#' Pre-process polII expression data
#'
#' @param expMat Path to the polII expression file generated by Miao's script
#' @param sampleId Sample id to be used
#' @param expFraction Fraction of the genes to be considered as expressed
#'   (normally 10\% genes are under active transcription in the cell)
#' @param polIIExpFile Complete path for processed output file
#'
#' @return complete output file path
#' @export
#'
#' @examples NA
preProcess_polII_expression <- function(expMat, sampleId, expFraction, polIIExpFile){

  polIIDf <- data.table::fread(input = expMat, header = F, drop = c(1,2,3,5,6),
                               col.names = c("gene", sampleId),  stringsAsFactors = F, sep = "\t", data.table = F)

  topFraction <- round(nrow(polIIDf) * expFraction / 100)

  expressedDf <- polIIDf %>% dplyr::top_n(topFraction, !! as.name(sampleId))

  isExpCol <- paste("is_expressed.", sampleId, sep = "")
  expressedDf[isExpCol] <- TRUE

  expressedDf <- expressedDf %>% dplyr::select(gene, starts_with("is_expressed"))


  finalDf <- dplyr::left_join(x = polIIDf, y = expressedDf, by = c("gene" = "gene")) %>%
    dplyr::mutate(!!isExpCol := ifelse(is.na(!! as.name(isExpCol)), FALSE, !! as.name(isExpCol)))

  write.table(x = finalDf, file = polIIExpFile, sep = "\t", col.names = T, quote = F, row.names = F)

  cat("Processed polII expression for sample ", sampleId, "\n")

  return(polIIExpFile)
}

##################################################################################

#' Pre-process peak annotation data
#'
#' This function processes the peak annotation generated for narrowPeak file by
#' function \code{narrowPeak_annotate()}. It prepares a gene level ChIPseq signal
#' file.
#'
#'
#' @param sampleId sample ID
#' @param peakAnnotation A file path or a dataframe.
#' The file should be macs2 narrowPeak file annotated with function
#' \code{narrowPeak_annotate()}.
#' Dataframe should be generated by \code{import_peak_annotation()} function. A subset of
#' rows can be provided for special downstream usage.
#' @param cdsFile BED file with gene information
#' @param peakFile macs2 output file. Should be narrowPeak or broadPeak file
#' @param bwFile bigWig format coverage track file
#' @param outFile Optional output file. Default: NULL which means the output is not stored
#' @param bindingInGene whether the factor bind in gene body like polII or not
#' @param fcCutoff fold enrichment cutoff for the peak. Default: 1 i.e. no cutoff
#' @param pvalCutoff log10_pvalue cutoff for the peak. Default: 1 i.e. no cutoff
#'
#' @return Returns a dataframe with processed peak annotation information
#' @export
#'
#' @examples NA
preProcess_macs2_results <- function(sampleId, peakAnnotation, cdsFile, peakFile, bwFile,
                                     outFile = NULL,
                                     bindingInGene = FALSE,
                                     fcCutoff = 1, pvalCutoff = 1){

  ## get CDS promoter coverage
  cdsGr <- rtracklayer::import.bed(con = cdsFile)
  promoterGr <- GenomicRanges::promoters(x = cdsGr, upstream = 500, downstream = 0)

  promoterCov <- region_coverage(regions = promoterGr, bwFile = bwFile, name = "promoterCov")
  promoterCovDf <- as.data.frame(mcols(promoterCov))[, c("name", "promoterCov")]

  peakAnnDf <- NULL

  tfCols <- sapply(
    X = c("peakDist", "featureCovFrac", "hasPeak", "peakCoverage", "peakPosition", "peakId", "peakType",
          "peakPval", "peakEnrichment", "preference"),
    FUN = function(x){ paste(x, ".", sampleId, sep = "") },
    simplify = F, USE.NAMES = T)

  if(is.data.frame(peakAnnotation)){
    peakAnnDf <- peakAnnotation %>%
      dplyr::filter_at(.vars = vars(starts_with("peakPval.")), .vars_predicate = all_vars(. >= !! pvalCutoff)) %>%
      dplyr::filter_at(.vars = vars(starts_with("peakEnrichment.")), .vars_predicate = all_vars(. >= !! fcCutoff))

  } else{
    ## import peak annotation generated by perl script
    peakAnnDf <- import_peak_annotation(sampleId = sampleId,
                                        peakAnnoFile = peakAnnotation,
                                        peakFile = peakFile,
                                        bwFile = bwFile,
                                        fcCutoff = fcCutoff, pvalCutoff = pvalCutoff) %>%
      dplyr::filter(!is.na(geneId))
  }


  ## get TSS targets
  filteredTssPeaks <- peak_targets_at_TSS(sampleId = sampleId, peakAnotation = peakAnnDf)

  ## get TES targets
  filteredTesPeaks <- peak_targets_at_TES(sampleId = sampleId, peakAnotation = peakAnnDf)

  ## if there are no peaks called in the data, this is needed to avoid the errors in the left_join functions downstream
  if(nrow(filteredTssPeaks) == 0){
    filteredTssPeaks$geneId <- as.character(filteredTssPeaks$geneId)
  }

  if(nrow(filteredTesPeaks) == 0){
    filteredTesPeaks$geneId <- as.character(filteredTesPeaks$geneId)
  }

  filteredPeaks <- dplyr::bind_rows(filteredTssPeaks, filteredTesPeaks)

  ## associate the peak with genes
  geneSet <- data.table::fread(file = cdsFile, header = F, select = c(1,2,3,4,6),
                               col.names = c("chr", "start", "end", "gene", "strand"))

  finalDf <- dplyr::left_join(x = geneSet, y = filteredPeaks, by = c("gene" = "geneId"))  %>%
    dplyr::left_join(y = promoterCovDf, by = c("gene" = "name")) %>%
    dplyr::mutate(
      !! tfCols$hasPeak := ifelse(is.na(!! as.name(tfCols$hasPeak)), FALSE, !!as.name(tfCols$hasPeak) ),
      !! tfCols$peakCoverage := ifelse(
        is.na(!! as.name(tfCols$peakCoverage)), promoterCov, !!as.name(tfCols$peakCoverage) )
    ) %>%
    dplyr::select(1:5, !! tfCols$hasPeak, !! tfCols$peakPosition, tfCols$peakType, tfCols$peakId,
                  everything(), -promoterCov) %>%
    dplyr::filter_at(.vars = vars(starts_with("hasPeak.")), .vars_predicate = all_vars(. == TRUE)) %>%
    dplyr::arrange(chr, start, desc(!!as.name(tfCols$peakPosition)), !!as.name(tfCols$preference))

  ## optionally save the data
  if(!is.null(outFile)){
    readr::write_tsv(x = finalDf, path = outFile, col_names = T)
    cat("Added TF binding information for : ", sampleId, "\n")

  }


  return(finalDf)
}

##################################################################################


#' Import peak annotation data
#'
#' This function reads the '*.nearestCDS.tab' file generated by function
#' \code{narrowPeak_annotate()}. For each peak, it calculates the peak coverage values.
#'
#' @param sampleId sample ID
#' @param peakAnnoFile macs2 peak annotation file generated by \code{narrowPeak_annotate()}.
#' @param peakFile macs2 output file. Should be narrowPeak or broadPeak file
#' @param bwFile bigWig format coverage track file
#' @param fcCutoff fold enrichment cutoff for the peak. Default: 1 i.e. no cutoff
#' @param pvalCutoff log10_pvalue cutoff for the peak. Default: 1 i.e. no cutoff
#' @param columns A vector of column names which should be returned. Allowed values are: \code{c(
#' "hasPeak", "peakPosition", "peakType", "peakId", "peakEnrichment", "peakPval", "peakQval",
#' "peakSummit", "peakDist", "summitDist", "bidirectional", "featureCovFrac", "relativeSummitPos",
#' "peakRegion", "peakCoverage")}. Default: all columns are returned
#'
#' @return A peak annotation as dataframe
#' @export
#'
#' @examples NA
import_peak_annotation <- function(sampleId, peakAnnoFile, peakFile, bwFile,
                                   fcCutoff = 1, pvalCutoff = 1,
                                   columns = NULL){


  ## "peakChr", "peakStart", "peakEnd", "peakSummit", "relativeSummitPos", "peakType", "peakDist",
  ## "featureCovFrac", "summitDist", "geneId", "txName", "peakPosition", "preference",
  ## "bidirectional", "peakId", "peakEnrichment", "peakPval", "peakQval", "peakCategory"

  renameCols <- c("peakId", "peakEnrichment", "peakPval", "peakQval", "peakSummit", "peakDist",
                  "summitDist", "peakType", "bidirectional", "featureCovFrac", "relativeSummitPos",
                  "peakRegion", "peakCoverage", "peakPosition", "preference", "peakCategory")

  names(renameCols) <- paste(renameCols, sampleId, sep = ".")

  peakFormat <- dplyr::case_when(
    grepl(pattern = ".narrowPeak$", x = peakFile, perl = T) ~ "narrowPeak",
    grepl(pattern = ".broadPeak$", x = peakFile, perl = T) ~ "broadPeak",
    grepl(pattern = ".bed$", x = peakFile, perl = T) ~ "bed"
  )

  ## read peak annotation output
  peakAnt <- suppressMessages(readr::read_tsv(file = peakAnnoFile, col_names = T)) %>%
    dplyr::filter(peakEnrichment >= !!fcCutoff) %>%
    dplyr::filter(peakPval >= !!pvalCutoff) %>%
    dplyr::mutate(peakRegion = paste(peakChr, ":", peakStart, "-", peakEnd, sep = ""))


  ## if there are no peaks called in the data, this is needed to avoid the errors in the left_join functions downstream
  if(nrow(peakAnt) == 0){

    peakAnt[1, ] <- NA
    peakAnt$type <- as.character(peakAnt$type)
    peakAnt$coverage <- NA
    warning("No peaks detected by macs2 for sample: ", sampleId, immediate. = TRUE)

  } else{
    ## get peak region coverage
    peakCov <- region_coverage(regions = peakFile, bwFile = bwFile, format = peakFormat, name = "peakCoverage")
    peakCovDf <- peakCov[, c("name", "peakCoverage")]

    peakAnt <- dplyr::left_join(x = peakAnt, y = peakCovDf, by = c("peakId" = "name"))

  }

  if(!is.null(columns)){
    peakAnt <- dplyr::select(peakAnt, !!! columns)
    renameCols <- renameCols[renameCols %in% columns]
  }

  peakAnt <- dplyr::rename(peakAnt, !!! renameCols)

  return(peakAnt)
}

##################################################################################

#' Extract genes from peak annotation data where binding is near TSS
#'
#'
#' @param sampleId sample ID
#' @param peakAnotation a dataframe containing peak annotation information generated by
#' function \code{import_peak_annotation}
#' @param bindingInGene whether the factor bind in gene body like polII or not
#'
#' @return A TSS target gene dataframe with sampleId added as suffix to column names
#' @export
#'
#' @examples NA
peak_targets_at_TSS <- function(sampleId, peakAnotation){

  ## new column names
  tfCols <- sapply(
    X = c("hasPeak", "peakType", "peakEnrichment", "relativeSummitPos", "peakCategory"),
    FUN = function(x){ paste(x, ".", sampleId, sep = "") },
    simplify = F, USE.NAMES = T
  )


  ## select the peaks which are in gene body and select the strongest peak
  insidePeaks <- dplyr::filter(peakAnotation, !! as.name(unname(tfCols$peakCategory)) == "peakInFeature") %>%
    dplyr::group_by(geneId) %>%
    dplyr::arrange(desc(!! as.name(tfCols$peakEnrichment)), .by_group = TRUE) %>%
    dplyr::slice(1L) %>%
    dplyr::ungroup()

  ## other peaks which are not inside
  nonInsidePeaks <- dplyr::filter(
    .data = peakAnotation,
    !! as.name(unname(tfCols$peakCategory)) %in% c("featureInPeak", "nearStart", "upstreamTss")
  )

  ## prepare TSS peakset and add hasPeak column
  tssPeakset <- dplyr::bind_rows(insidePeaks, nonInsidePeaks) %>%
    dplyr::mutate(!! tfCols$hasPeak := TRUE)

  return(tssPeakset)
}


##################################################################################

#' Extract genes from peak annotation data where binding is near TES
#'
#' @param sampleId sample ID
#' @param peakAnotation a dataframe containing peak annotation information generated by
#' function \code{import_peak_annotation}
#'
#' @return A TES target gene dataframe with sampleId added as suffix to column names
#' @export
#'
#' @examples NA
peak_targets_at_TES <- function(sampleId, peakAnotation){

  tfCols <- sapply(c("hasPeak", "peakCategory", "peakType", "peakEnrichment", "preference"),
                   FUN = function(x){ paste(x, ".", sampleId, sep = "") },
                   simplify = F, USE.NAMES = T)

  tesPeakset <- dplyr::filter(peakAnotation, !! as.name(unname(tfCols$peakCategory)) == "nearEnd") %>%
    dplyr::group_by(geneId) %>%
    dplyr::arrange(desc(!! as.name(tfCols$peakEnrichment)), .by_group = TRUE) %>%
    dplyr::slice(1L) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(!! tfCols$hasPeak := TRUE)

  return(tesPeakset)
}


##################################################################################




