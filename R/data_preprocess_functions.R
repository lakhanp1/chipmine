

##################################################################################
## function to process polII expression matrix and add top 10% info
#' Pre-process polII expression data
#'
#' @param expMat Path to the polII expression file generated by Miao's script
#' @param sampleId Sample id to be used
#' @param expFraction Fraction of the genes to be considered as expressed
#'   (normally 10\% genes are under active transcription in the cell)
#' @param polIIExpFile Complete path for processed output file
#'
#' @return complete output file path
#' @export
#'
#' @examples NA
preProcess_polII_expression <- function(expMat, sampleId, expFraction, polIIExpFile){

  polIIDf <- data.table::fread(input = expMat, header = F, drop = c(1,2,3,5,6),
                               col.names = c("gene", sampleId),  stringsAsFactors = F, sep = "\t", data.table = F)

  topFraction <- round(nrow(polIIDf) * expFraction / 100)

  expressedDf <- polIIDf %>% dplyr::top_n(topFraction, !! as.name(sampleId))

  isExpCol <- paste("is_expressed.", sampleId, sep = "")
  expressedDf[isExpCol] <- TRUE

  expressedDf <- expressedDf %>% dplyr::select(gene, starts_with("is_expressed"))


  finalDf <- dplyr::left_join(x = polIIDf, y = expressedDf, by = c("gene" = "gene")) %>%
    dplyr::mutate(!!isExpCol := ifelse(is.na(!! as.name(isExpCol)), FALSE, !! as.name(isExpCol)))

  write.table(x = finalDf, file = polIIExpFile, sep = "\t", col.names = T, quote = F, row.names = F)

  cat("Processed polII expression for sample ", sampleId, "\n")

  return(polIIExpFile)
}

##################################################################################


#' Import peak annotation data
#'
#' This function reads the '*.nearestCDS.tab' file generated by command:
#' \code{macs2 narrowPeak output | bedtools closest | perl bedtoolsClosestPeakAnnotate.pl}.
#' For each peak, it calculates the peak coverage values.
#'
#' @param sampleId sample ID
#' @param peakAnnoFile macs2 peak target gene found by \code{macs2 narrowPeak output |
#' bedtools closest | perl bedtoolsClosestPeakAnnotate.pl}
#' @param peakFile macs2 output file. Should be narrowPeak or broadPeak file
#' @param bwFile bigWig format coverage track file
#' @param fcCutoff fold enrichment cutoff for the peak. Default: 1 i.e. no cutoff
#' @param pvalCutoff log10_pvalue cutoff for the peak. Default: 1 i.e. no cutoff
#'
#' @return A peak annotation as dataframe
#' @export
#'
#' @examples NA
import_peak_annotation <- function(sampleId, peakAnnoFile, peakFile, bwFile, fcCutoff = 1, pvalCutoff = 1){

  peakFormat <- dplyr::case_when(
    grepl(pattern = ".narrowPeak$", x = peakFile, perl = T) ~ "narrowPeak",
    grepl(pattern = ".broadPeak$", x = peakFile, perl = T) ~ "broadPeak",
    grepl(pattern = ".bed$", x = peakFile, perl = T) ~ "bed"
  )

  ## read peak annotation output
  peakAnt <- suppressMessages(readr::read_tsv(file = peakAnnoFile, col_names = T)) %>%
    dplyr::filter(!is.na(gName)) %>%
    dplyr::filter(peakEnrichment >= !!fcCutoff) %>%
    dplyr::filter(peakPval >= !!pvalCutoff)


  ## if there are no peaks called in the data, this is needed to avoid the errors in the left_join functions downstream
  if(nrow(peakAnt) == 0){

    peakAnt[1, ] <- NA
    peakAnt$type <- as.character(peakAnt$type)
    peakAnt$coverage <- NA
    warning("No peaks detected by macs2 for sample: ", sampleId, immediate. = TRUE)

  } else{
    ## get peak region coverage
    peakCov <- region_coverage(regions = peakFile, bwFile = bwFile, format = peakFormat)
    peakCovDf <- peakCov[, c("name", "coverage")]

    peakAnt <- dplyr::left_join(x = peakAnt, y = peakCovDf, by = c("peakId" = "name"))
  }

  return(peakAnt)
}

##################################################################################

#' Extract genes from peak annotation data where binding is near TSS
#'
#' This function parse the peak annotation generated by \code{macs2 narrowPeak output |
#'  bedtools closest | perl bedtoolsClosestPeakAnnotate.pl} and extracts the genes which
#'  show peak near TSS.
#'
#' @param sampleId sample ID
#' @param peakAnotation a dataframe containing peak annotation information generated by
#' function \code{import_peak_annotation}
#' @param bindingInGene whether the factor bind in gene body like polII or not
#'
#' @return A TSS target gene dataframe with sampleId added as suffix to column names
#' @export
#'
#' @examples NA
peak_targets_at_TSS <- function(sampleId, peakAnotation, bindingInGene = FALSE){

  ## new column names
  tfCols <- sapply(
    X = c("hasPeak", "peakId", "pval", "peakType", "peakCoverage", "peakDist", "summitDist",
          "peakSummit", "enrichment", "upstreamExpr", "peakExpr", "relativeDist", "hasTesPeak",
          "tesPeakType", "tesPeakId", "tesSummitDist", "tesEnrichment", "tesPval"),
    FUN = function(x){ paste(x, ".", sampleId, sep = "") },
    simplify = F, USE.NAMES = T
  )

  ## TSS peak type preference order:
  tssTargetTypes <- data.frame(
    tssPeakType = c("includeFeature", "overlapStart", "insideOverlapStart",
                    "insideOverlapStartOverlapEnd", "upstream", "inside", "pseudo_upstream"),
    preference = 1:7,
    stringsAsFactors = F)

  if(isTRUE(bindingInGene)){
    tssTargetTypes <- data.frame(
      tssPeakType = c("includeFeature", "overlapStart", "insideOverlapStart",
                      "insideOverlapStartOverlapEnd", "inside", "insideOverlapEnd",
                      "overlapEnd", "upstream", "pseudo_upstream"),
      preference = c(1, 2, 3, 3, 3, 3, 4, 5, 6),
      stringsAsFactors = F)
  }


  tsspeaks <- dplyr::left_join(x = peakAnotation, y = tssTargetTypes, by = c("type" = "tssPeakType")) %>%
    filter(!is.na(preference))

  ## select the peaks which are in gene body and select the strongest peak
  insidePeaks <- dplyr::filter(tsspeaks, type == "inside") %>%
    dplyr::group_by(gName) %>%
    dplyr::arrange(desc(peakEnrichment), relativeSummitPos, .by_group = TRUE) %>%
    dplyr::slice(1L) %>%
    dplyr::ungroup()

  nonInsidePeaks <- dplyr::filter(tsspeaks, type != "inside")

  # filter(!grepl(pattern = "pseudo|overlapEnd", x = type, perl = T))

  ## select best peak for each gene based on peak type preference and distance
  tssPeakset <- dplyr::bind_rows(insidePeaks, nonInsidePeaks) %>%
    dplyr::mutate(!! tfCols$hasPeak := TRUE) %>%
    dplyr::rename(!! tfCols$peakSummit := peakSummit,
                  !! tfCols$peakId := peakId,
                  !! tfCols$peakDist := peakDist,
                  !! tfCols$summitDist := summitDist,
                  !! tfCols$peakType := type,
                  !! tfCols$enrichment := peakEnrichment,
                  !! tfCols$pval := peakPval,
                  !! tfCols$peakCoverage := coverage)

  return(tssPeakset)
}


##################################################################################

#' Extract genes from peak annotation data where binding is near TES
#'
#' This function parse the peak annotation generated by \code{macs2 narrowPeak output |
#'  bedtools closest | perl bedtoolsClosestPeakAnnotate.pl} and extracts the genes which
#'  show peak near TES
#'
#' @param sampleId sample ID
#' @param peakAnotation a dataframe containing peak annotation information generated by
#' function \code{import_peak_annotation}
#'
#' @return A TES target gene dataframe with sampleId added as suffix to column names
#' @export
#'
#' @examples NA
peak_targets_at_TES <- function(sampleId, peakAnotation){

  tfCols <- sapply(c("hasPeak", "peakId", "pval", "peakType", "peakCoverage", "peakDist", "summitDist",
                     "peakSummit", "enrichment", "upstreamExpr", "peakExpr", "relativeDist", "hasTesPeak",
                     "tesPeakType", "tesPeakId", "tesSummitDist", "tesEnrichment", "tesPval"),
                   FUN = function(x){ paste(x, ".", sampleId, sep = "") },
                   simplify = F, USE.NAMES = T)

  ## TES peak type preference
  tesTargetTypes <- data.frame(
    tesPeakType = c("overlapEnd", "pseudo_overlapEnd", "insideOverlapEnd",
                    "pseudo_insideOverlapEnd", "pseudo_inside"),
    preference = 1:5, stringsAsFactors = F)


  tesPeaks <- dplyr::left_join(x = peakAnotation, y = tesTargetTypes, by = c("type" = "tesPeakType")) %>%
    dplyr::filter(!is.na(preference))

  tesPeakset <- tesPeaks %>%
    dplyr::mutate(!! tfCols$hasTesPeak := TRUE) %>%
    dplyr::select(gName, !!tfCols$hasTesPeak, peakId, summitDist, type, peakEnrichment, peakPval, preference) %>%
    dplyr::rename(!! tfCols$tesPeakId := peakId,
                  !! tfCols$tesSummitDist := summitDist,
                  !! tfCols$tesPeakType := type,
                  !! tfCols$tesEnrichment := peakEnrichment,
                  !! tfCols$tesPval := peakPval)


  return(tesPeakset)
}


##################################################################################
## process macs2 out | bedtools closest | perl bedtoolsClosestPeakAnnotate.pl
#' Pre-process macs2 peak calling output
#'
#' This function process the '*.nearestCDS.tab' file generated by command:
#' \code{macs2 narrowPeak output | bedtools closest | perl bedtoolsClosestPeakAnnotate.pl}.
#' If a gene is target of multiple peaks, for TSS peaks preference order is: \emph{
#' includeFeature, overlapStart, insideOverlapStart, insideOverlapStartOverlapEnd,
#' inside, upstream, pseudo_upstream}
#' For TES peak, the preference order is: \emph{overlapEnd, pseudo_overlapEnd,
#' insideOverlapEnd, pseudo_insideOverlapEnd, pseudo_inside}
#'
#' @param sampleId sample ID
#' @param peakAnnotation A file path or a dataframe.
#' The file should be macs2 peak annotation file generated by command:
#' \code{macs2 narrowPeak output | bedtools closest | perl bedtoolsClosestPeakAnnotate.pl}.
#' Dataframe should be generated by \code{import_peak_annotation()} function. A subset of
#' rows can be provided for special downstream usage.
#' @param cdsFile BED file with gene information
#' @param peakFile macs2 output file. Should be narrowPeak or broadPeak file
#' @param bwFile bigWig format coverage track file
#' @param outFile Optional output file. Default: NULL which means the output is not stored
#' @param bindingInGene whether the factor bind in gene body like polII or not
#' @param fcCutoff fold enrichment cutoff for the peak. Default: 1 i.e. no cutoff
#' @param pvalCutoff log10_pvalue cutoff for the peak. Default: 1 i.e. no cutoff
#'
#' @return Returns a dataframe with processed peak annotation information
#' @export
#'
#' @examples NA
preProcess_macs2_results <- function(sampleId, peakAnnotation, cdsFile, peakFile, bwFile,
                                     outFile = NULL,
                                     bindingInGene = FALSE,
                                     fcCutoff = 1, pvalCutoff = 1){

  ## get CDS promoter coverage
  cdsGr <- rtracklayer::import.bed(con = cdsFile)
  promoterGr <- GenomicRanges::promoters(x = cdsGr, upstream = 500, downstream = 0)

  promoterCov <- region_coverage(regions = promoterGr, bwFile = bwFile, name = "promoterCov")
  promoterCovDf <- as.data.frame(mcols(promoterCov))[, c("name", "promoterCov")]

  peakAnnDf <- NULL

  if(is.data.frame(peakAnnotation)){
    peakAnnDf <- peakAnnotation

  } else{
    ## import peak annotation generated by perl script
    peakAnnDf <- import_peak_annotation(sampleId = sampleId,
                                        peakAnnoFile = peakAnnotation,
                                        peakFile = peakFile,
                                        bwFile = bwFile,
                                        fcCutoff = fcCutoff, pvalCutoff = pvalCutoff)
  }



  tfCols <- sapply(c("hasPeak", "peakId", "pval", "peakType", "peakCoverage", "peakDist", "summitDist",
                     "peakSummit", "enrichment", "upstreamExpr", "peakExpr", "relativeDist", "hasTesPeak",
                     "tesPeakType", "tesPeakId", "tesSummitDist", "tesEnrichment", "tesPval"),
                   FUN = function(x){ paste(x, ".", sampleId, sep = "") },
                   simplify = F, USE.NAMES = T)

  ## get TSS targets
  filteredTssPeaks <- peak_targets_at_TSS(sampleId = sampleId, peakAnotation = peakAnnDf,
                                          bindingInGene = bindingInGene) %>%
    dplyr::group_by(gName) %>%
    dplyr::arrange(preference, abs(!! as.name(tfCols$peakDist)), dplyr::desc(featureCovFrac), .by_group = TRUE) %>%
    dplyr::slice(1L) %>%
    dplyr::ungroup() %>%
    dplyr::select(-preference)

  ## get TES targets
  filteredTesPeaks <- peak_targets_at_TES(sampleId = sampleId, peakAnotation = peakAnnDf) %>%
    dplyr::group_by(gName) %>%
    dplyr::arrange(preference, .by_group = TRUE) %>%
    dplyr::slice(1L) %>%
    dplyr::ungroup() %>%
    dplyr::select(-preference)

  ## if there are no peaks called in the data, this is needed to avoid the errors in the left_join functions downstream
  if(nrow(filteredTssPeaks) == 0){
    filteredTssPeaks$gName <- as.character(filteredTssPeaks$gName)
  }

  if(nrow(filteredTesPeaks) == 0){
    filteredTesPeaks$gName <- as.character(filteredTesPeaks$gName)
  }

  ## associate the peak with genes
  geneSet <- data.table::fread(file = cdsFile, header = F, select = c(1,2,3,4,6),
                               col.names = c("chr", "start", "end", "gene", "strand"))

  finalDf <- dplyr::left_join(x = geneSet, y = filteredTssPeaks, by = c("gene" = "gName"))  %>%
    dplyr::left_join(y = promoterCovDf, by = c("gene" = "name")) %>%
    dplyr::mutate(
      !! tfCols$hasPeak := ifelse(is.na(!! as.name(tfCols$hasPeak)), FALSE, !!as.name(tfCols$hasPeak) ),
      !! tfCols$peakCoverage := ifelse(
        is.na(!! as.name(tfCols$peakCoverage)), promoterCov, !!as.name(tfCols$peakCoverage) )
    ) %>%
    dplyr::select(1:5, !! tfCols$hasPeak, everything(), -promoterCov) %>%
    dplyr::left_join(y = filteredTesPeaks, by = c("gene" = "gName")) %>%
    dplyr::mutate(!! tfCols$hasTesPeak := ifelse(
      is.na(!! as.name(tfCols$hasTesPeak)), FALSE, !!as.name(tfCols$hasTesPeak) )
    )

  ## optionally save the data
  if(!is.null(outFile)){
    readr::write_tsv(x = finalDf, path = outFile, col_names = T)
    cat("Added TF binding information for : ", sampleId, "\n")

  }


  return(finalDf)
}

##################################################################################






