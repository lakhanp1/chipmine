

##################################################################################
## function to process polII expression matrix and add top 10% info
## ou can add an ROxygen2 skeleton for a function by placing your cursor inside the function then pressing ctr+alt+shift+R
#' Pre-process polII expression data
#'
#' @param expMat Path to the polII expression file generated by Miao's script
#' @param title Sample id to be used
#' @param expFraction Fraction of the genes to be considered as expressed
#'   (normally 10\% genes are under active transcription in the cell)
#' @param polIIExpFile Complete path for processed output file
#'
#' @return complete output file path
#' @export
#'
#' @examples NA
preProcess_polII_expression <- function(expMat, title, expFraction, polIIExpFile){

  polIIDf <- data.table::fread(input = expMat, header = F, drop = c(1,2,3,5,6), col.names = c("gene", title),  stringsAsFactors = F, sep = "\t", data.table = F)

  topFraction <- round(nrow(polIIDf) * expFraction / 100)

  expressedDf <- polIIDf %>% dplyr::top_n(topFraction, !! as.name(title))

  isExpCol <- paste("is_expressed.", title, sep = "")
  expressedDf[isExpCol] <- TRUE

  expressedDf <- expressedDf %>% dplyr::select(gene, starts_with("is_expressed"))


  finalDf <- dplyr::left_join(x = polIIDf, y = expressedDf, by = c("gene" = "gene")) %>%
    dplyr::mutate(!!isExpCol := ifelse(is.na(!! as.name(isExpCol)), FALSE, !! as.name(isExpCol)))

  write.table(x = finalDf, file = polIIExpFile, sep = "\t", col.names = T, quote = F, row.names = F)

  cat("Processed polII expression for sample ", title, "\n")

  return(polIIExpFile)
}

##################################################################################




##################################################################################
## process macs2 out | bedtools closest | perl bedtoolsClosestPeakAnnotate.pl
#' Pre-process macs2 peak calling output
#'
#' This function process the '*.nearestCDS.tab' file generated by command:
#' "macs2 narrowPeak output | bedtools closest | perl bedtoolsClosestPeakAnnotate.pl".
#' If a gene is target of multiple peaks, for TSS peaks preference order is: "includeFeature",
#' "overlapStart", "insideOverlapStart", "insideOverlapStartOverlapEnd", "inside", "upstream",
#'  "pseudo_upstream".
#'  For TES peak, the preference order is: "overlapEnd", "pseudo_overlapEnd", "insideOverlapEnd", "pseudo_insideOverlapEnd", "pseudo_inside".
#'
#' @param title sample ID
#' @param peakAnnoFile macs2 peak target gene found by "macs2 narrowPeak output | bedtools closest | perl bedtoolsClosestPeakAnnotate.pl"
#' @param cdsFile BED file with gene information
#' @param peakFile macs2 output file. Should be narrowPeak or broadPeak file
#' @param bwFile bigWig format coverage track file
#' @param outFile output file
#' @param bindingInGene whether the factor bind in gene body like polII or not
#' @param fcCutoff fold enrichment cutoff for the peak. Default: 1 i.e. no cutoff
#' @param pvalCutoff log10_pvalue cutoff for the peak. Default: 1 i.e. no cutoff

#'
#' @return Returns nothing
#' @export
#'
#' @examples NA
preProcess_macs2_results <- function(title, peakAnnoFile, cdsFile, peakFile, bwFile,
                                     outFile,
                                     bindingInGene = FALSE,
                                     fcCutoff = 1, pvalCutoff = 1){

  ## get CDS promoter coverage
  cdsGr <- rtracklayer::import.bed(con = cdsFile)
  promoterGr <- GenomicRanges::promoters(x = cdsGr, upstream = 500, downstream = 0)

  promoterCov <- region_coverage(regions = promoterGr, bwFile = bwFile, name = "promoterCov")
  promoterCovDf <- as.data.frame(mcols(promoterCov))[, c("name", "promoterCov")]


  peakFormat <- case_when(
    grepl(pattern = ".narrowPeak$", x = peakFile, perl = T) ~ "narrowPeak",
    grepl(pattern = ".broadPeak$", x = peakFile, perl = T) ~ "broadPeak",
    grepl(pattern = ".bed$", x = peakFile, perl = T) ~ "bed"
  )


  ## new column names
  peakCol <- paste("hasPeak.", title, sep = "")
  peakIdCol <- paste("peakId.", title, sep = "")
  summitCol <- paste("peakSummit.", title, sep = "")
  distCol <- paste("peakDist.", title, sep = "")
  summitDistCol <- paste("summitDist.", title, sep = "")
  fcCol <- paste("enrichment.", title, sep = "")
  pvalCol <- paste("pval.", title, sep = "")
  peakTypeCol <- paste("peakType.", title, sep = "")
  peakCovCol <- paste("peakCoverage.", title, sep = "")

  tesPeakCol <- paste("hasTesPeak.", title, sep = "")
  tesPeakIdCol <- paste("tesPeakId.", title, sep = "")
  tesPeakTypeCol <- paste("tesPeakType.", title, sep = "")
  tesSummitDistCol <- paste("tesSummitDist.", title, sep = "")
  tesFcCol <- paste("tesEnrichment.", title, sep = "")
  tesPvalCol <- paste("tesPval.", title, sep = "")

  ## read peak annotation output
  peakAnnDf <- data.table::fread(file = peakAnnoFile, header = T, stringsAsFactors = F, sep = "\t", na.strings = "NA") %>%
    dplyr::filter(!is.na(gName)) %>%
    dplyr::filter(peakEnrichment >= !!fcCutoff) %>%
    dplyr::filter(peakPval >= !!pvalCutoff)


  ## if there are no peaks called in the data, this is needed to avoid the errors in the left_join functions downstream
  if(nrow(peakAnnDf) == 0){

    peakAnnDf[1, ] <- NA
    peakAnnDf$type <- as.character(peakAnnDf$type)
    peakAnnDf$coverage <- NA
    warning("No peaks detected by macs2 for sample: ", title, immediate. = TRUE)

  } else{
    ## get peak region coverage
    peakCov <- region_coverage(regions = peakFile, bwFile = bwFile, format = peakFormat)
    peakCovDf <- peakCov[, c("name", "coverage")]

    peakAnnDf <- dplyr::left_join(x = peakAnnDf, y = peakCovDf, by = c("peakId" = "name"))
  }

  ## TSS peak type preference order:
  tssTargetTypes <- data.frame(tssPeakType = c("includeFeature", "overlapStart", "insideOverlapStart", "insideOverlapStartOverlapEnd", "upstream", "inside", "pseudo_upstream"),
                               preference = 1:7,
                               stringsAsFactors = F)

  if(isTRUE(bindingInGene)){
    tssTargetTypes <- data.frame(tssPeakType = c("includeFeature", "overlapStart", "insideOverlapStart", "insideOverlapStartOverlapEnd", "inside", "insideOverlapEnd", "overlapEnd", "upstream", "pseudo_upstream"),
                                 preference = c(1, 2, 3, 3, 3, 3, 4, 5, 6),
                                 stringsAsFactors = F)
  }


  tsspeaks <- dplyr::left_join(x = peakAnnDf, y = tssTargetTypes, by = c("type" = "tssPeakType")) %>%
    filter(!is.na(preference))

  # filter(!grepl(pattern = "pseudo|overlapEnd", x = type, perl = T))

  ## select best peak for each gene based on peak type preference and distance
  filteredTssPeaks <- tsspeaks %>%
    dplyr::group_by(gName) %>%
    dplyr::arrange(preference, abs(peakDist), dplyr::desc(featureCovFrac)) %>%
    dplyr::slice(1L) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(!! peakCol := TRUE) %>%
    dplyr::rename(!! summitCol := peakSummit,
                  !! peakIdCol := peakId,
                  !! distCol := peakDist,
                  !! summitDistCol := summitDist,
                  !! peakTypeCol := type,
                  !! fcCol := peakEnrichment,
                  !! pvalCol := peakPval,
                  !! peakCovCol := coverage)


  ## TES peak type preference
  tesTargetTypes <- data.frame(tesPeakType = c("overlapEnd", "pseudo_overlapEnd", "insideOverlapEnd", "pseudo_insideOverlapEnd", "pseudo_inside"),
                               preference = 1:5, stringsAsFactors = F)


  tesPeaks <- dplyr::left_join(x = peakAnnDf, y = tesTargetTypes, by = c("type" = "tesPeakType")) %>%
    dplyr::filter(!is.na(preference))

  filteredTesPeaks <- tesPeaks %>%
    dplyr::group_by(gName) %>%
    dplyr::arrange(preference) %>%
    dplyr::slice(1L) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(!! tesPeakCol := TRUE) %>%
    dplyr::select(gName, !!tesPeakCol, peakId, summitDist, type, peakEnrichment, peakPval) %>%
    dplyr::rename(!! tesPeakIdCol := peakId,
                  !! tesSummitDistCol := summitDist,
                  !! tesPeakTypeCol := type,
                  !! tesFcCol := peakEnrichment,
                  !! tesPvalCol := peakPval)


  ## if there are no peaks called in the data, this is needed to avoid the errors in the left_join functions downstream
  if(nrow(filteredTssPeaks) == 0){
    filteredTssPeaks$gName <- as.character(filteredTssPeaks$gName)
  }

  if(nrow(filteredTesPeaks) == 0){
    filteredTesPeaks$gName <- as.character(filteredTesPeaks$gName)
  }

  ## associate the peak with genes
  geneSet <- data.table::fread(file = cdsFile, header = F, select = c(1,2,3,4,6), col.names = c("chr", "start", "end", "gene", "strand"))

  finalDf <- dplyr::left_join(x = geneSet, y = filteredTssPeaks, by = c("gene" = "gName"))  %>%
    dplyr::left_join(y = promoterCovDf, by = c("gene" = "name")) %>%
    dplyr::mutate(
      !! peakCol := ifelse(is.na(!! as.name(peakCol)), FALSE, !!as.name(peakCol) ),
      !! peakCovCol := ifelse(is.na(!! as.name(peakCovCol)), promoterCov, !!as.name(peakCovCol) )
    ) %>%
    dplyr::select(1:5, !! peakCol, everything(), -promoterCov) %>%
    dplyr::left_join(y = filteredTesPeaks, by = c("gene" = "gName")) %>%
    dplyr::mutate(!! tesPeakCol := ifelse(is.na(!! as.name(tesPeakCol)), FALSE, !!as.name(tesPeakCol) ) )


  write.table(x = finalDf, file = outFile, sep = "\t", col.names = T, quote = F, row.names = F)

  cat("Added TF binding information for: ", title, "\n")

}

##################################################################################



##################################################################################

#' Calculate mean coverage for regions.
#'
#' This function calculate the coverage for the regions provided as bed/narrowPeak/broadPeak
#' format file from a bigWig file. For each region, it adds the depth and divide it by the
#' region length. NOTE: It assumes that the bigWig file is already scalled (e.g. 1 million)
#' and hence does perform scalling or normalization.
#'
#' @param regions Either GenomicRanges object or a file in bed, narrowPeak or broadPeak format
#' @param format format of the peak file. Should be one of "bed", "narrowPeak" or "broadPeak".
#' This option does not matter if the 'regions' argument if a GRanges object.
#' @param bwFile bigWig file from which the coverage will be calculated
#' @param name Name of the coverage column. Default: coverage
#'
#' @return If the regions is a GRanges object, then same object is returned with additional
#' coverage column. Otherwise a dataframe is returned.
#' @export
#'
#' @examples
region_coverage <- function(regions, format = "narrowPeak", bwFile, name = "coverage"){

  regionGr <- NULL
  returnType <- "df"

  if(any(class(regions) %in% c("GRanges"))){
    regionGr <- regions
    returnType <- "GRanges"
  } else{
    regionGr <- rtracklayer::import(con = regions, format = format)
  }

  bwGr <- rtracklayer::import.bw(con = bwFile, as = "RleList")

  mcols(regionGr)[[ name ]] <- 0

  ## get coverage for each chromosome
  for (chr in seqinfo(regionGr)@seqnames) {
    chrScore <- sum(IRanges::Views(
      subject = bwGr[[chr]],
      ranges(regionGr[seqnames(regionGr) == chr]))) / width(regionGr[seqnames(regionGr) == chr])

    mcols(regionGr[seqnames(regionGr) == chr])[[ name ]] <- chrScore

  }

  if(returnType == "df"){
    return(as.data.frame(mcols(regionGr)))
  } else{
    return(regionGr)
  }

}


##################################################################################





