
#' Annotate peak targets in UTR regions
#'
#' @param queryGr GRanges object generated from narrowPeak or broadPeak file
#' @param subjectGrl GRangesList object for CDS generated by \code{GenomicFeatures::fiveUTRsByTranscript()}
#' or \code{GenomicFeatures::threeUTRsByTranscript()}
#' @param utrType A character string either of \code{"5UTR"} or \code{"3UTR"}. This string is added
#' as peakType column value for the peaks which overlap the respective UTR region.
#'
#' @return A modified peak GRanges object with two additional columns: \code{peakType, tx_id}
#' @export
#'
#' @examples NA
UTR_annotate <- function(queryGr, subjectGrl, utrType, txdb){

  if(class(subjectGrl) != "CompressedGRangesList"){
    stop("subjectGrl should be a GRangesList object")
  }

  ## remember to combine the multi-exon UTRs from UTR GRangesList
  utrGr <- unlist(range(subjectGrl))
  mcols(utrGr)$tx_id <- names(utrGr)

  utrOvlp <- GenomicRanges::findOverlaps(query = queryGr, subject = utrGr)

  queryTargets <- queryGr[utrOvlp@from]
  mcols(queryTargets)$tx_id <- mcols(utrGr)$tx_id[utrOvlp@to]
  mcols(queryTargets)$peakType <- utrType
  mcols(queryTargets)$peakDist <- 0

  ## get respective transcripts for each UTR
  ## featureCovFrac is at transcript level
  transcriptsGrl <- GenomicFeatures::mapIdsToRanges(x = txdb,
                                                    keys = list(tx_id = mcols(queryTargets)$tx_id),
                                                    type = "tx")
  transcriptGr <- unlist(transcriptsGrl)



  mcols(queryTargets)$targetStart = start(transcriptGr)
  mcols(queryTargets)$targetEnd = end(transcriptGr)
  mcols(queryTargets)$targetStrand = strand(transcriptGr)
  mcols(queryTargets)$featureCovFrac <- as.numeric(
    sprintf(fmt = "%.3f", width(pintersect(x = queryTargets, y = transcriptGr)) / width(transcriptGr))
  )

  utrTargetsDf <- as.data.frame(queryTargets) %>%
    dplyr::mutate(
      summitDist = dplyr::case_when(
        targetStrand == "+" ~ peakSummit - targetStart,
        targetStrand == "-" ~ targetEnd - peakSummit
      )
    ) %>%
    dplyr::select(-targetStart, -targetEnd, -targetStrand)

  utrTargetsGr <- makeGRangesFromDataFrame(df = utrTargetsDf, keep.extra.columns = TRUE)
  return(utrTargetsGr)
}



##################################################################################



#' Map peaks to given GRanges regions
#'
#' This function annotates the peaks onto a regions into e.g. \code{CDS_start, CDS_end, include_CDS,
#' inside_CDS} categories.
#' In addition, relativeSummitPos value is updated w.r.t. region for the peaks which are
#' annotated as e.g. \code{inside_CDS}
#'
#' @param queryGr GRanges object generated from narrowPeak or broadPeak file
#' @param subjectGrl GRanges object for regions on which peaks needs to be mapped. E.g:
#'  \code{GenomicFeatures::cdsBy()} or \code{GenomicFeatures::transcripts()}
#' @param includeFractionCut A cutoff on peak coverage value of CDS. If peak covers more
#' than this proportion of CDS, it is annotated as \code{inside_CDS}. Default: 0.7
#'
#' @return A modified peak GRanges object with two additional columns: \code{peakType, tx_id}
#' @export
#'
#' @examples NA
region_overlap_annotate <- function(queryGr, subjectGr, includeFractionCut = 0.7, name = "CDS"){

  if(includeFractionCut < 0 || includeFractionCut > 1){
    stop("Invalid includeFractionCut value. Should be in range [0, 1]")
  }

  ## define feature types
  insideFeature <- paste("inside_", name, sep = "")
  includeFeature <- paste("include_", name, sep = "")
  overlapStart <- paste(name, "_start", sep = "")
  overlapEnd <- paste(name, "_end", sep = "")


  ovlpHits <- GenomicRanges::findOverlaps(query = queryGr, subject = subjectGr)

  queryTargets <- queryGr[ovlpHits@from]
  mcols(queryTargets)$tx_id <- mcols(subjectGr)$tx_id[ovlpHits@to]
  mcols(queryTargets)$peakType <- insideFeature
  mcols(queryTargets)$peakDist <- 0

  ##
  mcols(queryTargets)$targetStart = start(subjectGr[ovlpHits@to])
  mcols(queryTargets)$targetEnd = end(subjectGr[ovlpHits@to])
  mcols(queryTargets)$targetStrand = strand(subjectGr[ovlpHits@to])
  mcols(queryTargets)$featureCovFrac <- as.numeric(
    sprintf(fmt = "%.3f", width(pintersect(x = queryTargets, y = subjectGr[ovlpHits@to])) / width(subjectGr[ovlpHits@to])))

  ## assign appropriate target location
  ## if the peak is inside_CDS, update the relativeSummitPos w.r.t. CDS
  ##
  ##     |>=====>=====>======>======>======>|            |<=====<=====<======<======<======<|
  ##   -------                                                                           --------
  ##                                    -------       -------
  ##                 -------                                          --------
  ##  -------------------------------------------     -------------------------------------------
  ##
  targetsDf <- as.data.frame(queryTargets) %>%
    dplyr::mutate(
      peakType = dplyr::case_when(
        peakStart <= targetStart & peakEnd >= targetEnd ~ includeFeature,
        featureCovFrac >= includeFractionCut ~ includeFeature,
        targetStrand == "+" & peakStart <= targetStart & peakEnd < targetEnd ~ overlapStart,
        targetStrand == "+" & targetStart < peakStart & targetEnd <= peakEnd ~ overlapEnd,
        targetStrand == "-" & peakStart <= targetStart & peakEnd < targetEnd ~ overlapEnd,
        targetStrand == "-" & targetStart < peakStart & targetEnd <= peakEnd ~ overlapStart,
        TRUE ~ insideFeature
      )
    ) %>%
    dplyr::mutate(
      summitDist = dplyr::case_when(
        peakType != overlapEnd && targetStrand == "+" ~ peakSummit - targetStart,
        peakType != overlapEnd && targetStrand == "-" ~ targetEnd - peakSummit,
        peakType == overlapEnd && targetStrand == "+" ~ peakSummit - targetEnd,
        peakType == overlapEnd && targetStrand == "-" ~ targetStart - peakSummit
      ),
      relativeSummitPos = dplyr::if_else(
        condition = peakType == insideFeature,
        true = as.numeric(sprintf("%.3f", (peakSummit - targetStart) / (targetEnd - targetStart))),
        false = relativeSummitPos
      )
    ) %>%
    dplyr::select(-targetStart, -targetEnd, -targetStrand)

  ## convert back to GRanges
  queryTargets <- makeGRangesFromDataFrame(df = targetsDf, keep.extra.columns = TRUE)

  return(queryTargets)
}


set_target_gr_to_pseudo <- function(target){
  mcols(target)$peakType <- paste("pseudo_", mcols(target)$peakType, sep = "")
  return(target)
}

set_target_df_to_pseudo <- function(target){
  target$peakType <- paste("pseudo_", target$peakType, sep = "")
  return(target)
}



##################################################################################


#' Annotate upstream peaks on transcripts
#'
#' @param peaksGr GRanges object for peak data
#' @param featuresGr A transcript GRanges object
#' @param ... Other arguments for \code{nearest_upstream_bidirectional()} function
#'
#' @return A modified peak GRanges object with two additional columns: \code{peakType, tx_id}
#' @export
#'
#' @examples NA
upstream_annotate <- function(peaksGr, featuresGr, ...){
  ## using transcripts as query because we need to handle bidirectional peaks
  ## if peaks is used as query, only one downstream gene is reported for each peak
  ## so it will be difficult to extract bidirectional peaks
  ## if transcripts is used as query, a peak upstream of each transcript could be found
  ## so two transcripts can mark one single peak
  upstreamHits <- GenomicRanges::follow(x = featuresGr, subject = peaksGr, select = "all")

  ## find the number of genes between peak and its target.
  ## only those targets are true where there is no gene inbetween
  ## build a GRanges object of the gap region between peak and target gene
  peakTargetGapsGr <- GenomicRanges::pgap(x = featuresGr[upstreamHits@from],
                                          y = peaksGr[upstreamHits@to])

  names(peakTargetGapsGr) <- mcols(featuresGr[upstreamHits@from])$tx_id
  peakTargetGapsGr <- unstrand(peakTargetGapsGr)

  ## count overlapping genes in gap region
  genesBetween <- GenomicRanges::countOverlaps(query = peakTargetGapsGr,
                                               subject = GenomicFeatures::genes(txdb),
                                               ignore.strand = TRUE)

  genesBetweenDf <- data.frame(tx_id = as.numeric(names(genesBetween)),
                               nGenesBetween = genesBetween,
                               stringsAsFactors = FALSE)


  ## build upstream peaks data and filter unnecessary peaks where there is/are genes between peak and target
  upstreamPeaks <- peaksGr[upstreamHits@to]

  mcols(upstreamPeaks)$tx_id <- mcols(featuresGr)$tx_id[upstreamHits@from]
  mcols(upstreamPeaks)$peakType <- "upstream"
  mcols(upstreamPeaks)$peakDist <- GenomicRanges::distance(x = featuresGr[upstreamHits@from],
                                                           y = peaksGr[upstreamHits@to])
  mcols(upstreamPeaks)$peakDist <- mcols(upstreamPeaks)$peakDist * -1
  # mcols(upstreamPeaks)$featureCovFrac <- 0
  # mcols(upstreamPeaks)$summitDist <- 0

  mcols(upstreamPeaks)$targetStart = start(featuresGr[upstreamHits@from])
  mcols(upstreamPeaks)$targetEnd = end(featuresGr[upstreamHits@from])
  mcols(upstreamPeaks)$targetStrand = strand(featuresGr[upstreamHits@from])


  upstreamPeaksDf <- as.data.frame(upstreamPeaks, stringsAsFactors = FALSE) %>%
    dplyr::left_join(y = genesBetweenDf, by = c("tx_id" = "tx_id")) %>%
    dplyr::filter(nGenesBetween == 0) %>%
    dplyr::mutate(
      featureCovFrac = 0,
      summitDist = dplyr::case_when(
        targetStrand == "+" ~ peakSummit - targetStart,
        targetStrand == "-" ~ targetEnd - peakSummit
      )
    )


  bidirectionalPairs <- dplyr::group_by(upstreamPeaksDf, name) %>%
    dplyr::arrange(desc(peakDist), .by_group = T) %>%
    dplyr::mutate(n = n()) %>%
    dplyr::do(nearest_upstream_bidirectional(bdirTargets = .)) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(seqnames, start) %>%
    as.data.frame() %>%
    dplyr::select(-targetStart, -targetEnd, -targetStrand, -nGenesBetween, -n)

  upstreamPeaksAn <- makeGRangesFromDataFrame(bidirectionalPairs, keep.extra.columns = T)

  return(upstreamPeaksAn)
}



##################################################################################


#' True target for bidirectional peak
#'
#' This function
#'
#'     target1              peak                         target2
#'
#' ==<=====<=====<===     -------             ===>=====>=====>=====>==
#'
#'                                |
#'                    center between two targets
#'
#' True target: target1: more than 80% of the peak lies on target1 side
#'
#' @param bdirTargets A dataframe with two rows for bidirectional targets
#' @param skewFraction Minimum fraction of peak region allowed on the side of false target
#' from the midpoint of two target genes. Default: 0.2
#' @param minTSS_gapForPseudo Valid distance between two target genes TSS to decide one as psuedo
#'
#' @return Same dataframe in which peakType for one of the target is marked as pseudo
#' @export
#'
#' @examples NULL
nearest_upstream_bidirectional <- function(bdirTargets, skewFraction = 0.2, minTSS_gapForPseudo = 500){


  ##     target1              peak                         target2
  ## ==<=====<=====<===     -------             ===>=====>=====>=====>==
  ##                                |
  ##                    center between two targets
  ## True target: target1: more than 80% of the peak lies on target1 side

  if(nrow(bdirTargets) == 1){
    return(bdirTargets)
  } else if(nrow(bdirTargets) > 2){
    stop("Unhandled behaviour: 3 targets for bidirectional peaks")
  }

  if(all(bdirTargets$targetStrand %in% c("+", "-")) && bdirTargets$targetStrand[1] != bdirTargets$targetStrand[2]){

    posTg <- bdirTargets[ which(bdirTargets$targetStrand == "+"), ]
    negTg <- bdirTargets[ which(bdirTargets$targetStrand == "-"), ]

    ## gap center
    gapStart <- negTg$targetEnd
    gapEnd <- posTg$targetStart
    gapWidth <- gapEnd - gapStart
    gapCenter <- negTg$targetEnd + (gapWidth / 2)

    peakWidth <- posTg$peakEnd - posTg$peakStart
    peakFraction <- peakWidth * skewFraction

    ## if the distance between the TSS of two bidirectional targets < minTSS_gapForPseudo:
    ## CANNOT decide the pseudo target confidently
    if(gapWidth > minTSS_gapForPseudo){

      if((posTg$peakEnd - peakFraction) <= gapCenter){
        ## negative strand target is true; set positive strand target to pseudo
        posTg <- set_target_df_to_pseudo(target = posTg)

      } else if((posTg$peakStart + peakFraction) >= gapCenter){
        ## positive strand target is true; set negative strand target to pseudo
        negTg <- set_target_df_to_pseudo(target = negTg)

      }
    }

    return(dplyr::bind_rows(posTg, negTg))

  }

  return(bdirTargets)
}


##################################################################################





